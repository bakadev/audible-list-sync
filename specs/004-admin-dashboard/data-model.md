# Data Model: Admin Dashboard & Data Import

**Feature**: Admin Dashboard & Data Import
**Branch**: `004-admin-dashboard`
**Date**: 2026-02-11

## Overview

This document defines the data model for the admin dashboard and data import feature. The model introduces a centralized title catalog architecture where shared book metadata (from Audnex API) is stored once in the Title table, while user-specific data (ratings, progress, listening status) is stored in LibraryEntry join records. This design enables efficient data normalization and eliminates metadata duplication across users.

The admin role system uses a simple boolean flag on the User model, allowing a designated user to access management functions for users, titles, and library data.

## Entities

### User

Represents a registered user account with optional admin privileges.

**Purpose**: Authenticate users and control access to admin functions. Each user owns zero or more LibraryEntry records that link them to titles in their personal library or wishlist.

**Source**: NextAuth authentication system (existing), extended with admin role flag.

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `id` | string (cuid) | Yes | Unique user identifier | Auto-generated by database |
| `email` | string | Yes | User's email address (from auth provider) | Valid email format, unique across all users |
| `name` | string | No | User's display name (from auth provider) | Max 255 characters |
| `image` | string | No | User's profile image URL (from auth provider) | Valid URL format |
| `isAdmin` | boolean | Yes | Admin role flag | Defaults to `false`. Set to `true` if email matches `ADMIN_EMAIL` environment variable on login |
| `createdAt` | datetime | Yes | Account creation timestamp | Auto-generated on insert |
| `updatedAt` | datetime | Yes | Last update timestamp | Auto-updated on any field change |

#### Relationships

- **Has many** LibraryEntry (one-to-many): A user can have zero or more titles in their library/wishlist
- **Has many** SyncHistory (one-to-many): A user can have multiple import operations logged

#### Example Instances

**Regular User**:
```json
{
  "id": "clx1a2b3c4d5e6f7g8h9i0j",
  "email": "user@example.com",
  "name": "Jane Doe",
  "image": "https://example.com/avatar.jpg",
  "isAdmin": false,
  "createdAt": "2026-02-10T14:30:00Z",
  "updatedAt": "2026-02-10T14:30:00Z"
}
```

**Admin User**:
```json
{
  "id": "clx9z8y7x6w5v4u3t2s1r0q",
  "email": "admin@example.com",
  "name": "Admin User",
  "image": null,
  "isAdmin": true,
  "createdAt": "2026-01-15T09:00:00Z",
  "updatedAt": "2026-02-11T10:15:00Z"
}
```

#### Validation Rules

**Cross-Field Validation**:
- Email uniqueness enforced at database level
- Admin role auto-assigned on login if `email === process.env.ADMIN_EMAIL`
- Only one admin email supported in MVP (can be extended to multiple admins later)

**Field-Specific Constraints**:
- `email`: Must match regex `/^[^\s@]+@[^\s@]+\.[^\s@]+$/` (basic email validation)
- `isAdmin`: Cannot be set directly via API, only through auto-assignment logic on login
- `id`: Cannot be updated after creation (immutable primary key)

---

### Title

Represents an audiobook with comprehensive metadata fetched from Audnex API. Serves as the canonical source of book information shared across all users.

**Purpose**: Store book metadata once and reference it from multiple user libraries. Eliminates duplication of author names, cover images, descriptions, etc. across user-specific records.

**Source**: Audnex API (https://api.audnex.us/books/{asin}) - fetched during import when ASIN is not found in existing titles.

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `asin` | string | Yes | Audible Standard Identification Number (unique product ID) | Alphanumeric, typically 10 characters (e.g., "B09GHRGYRF"). Primary key. |
| `title` | string | Yes | Book title | Non-empty, max 500 characters |
| `subtitle` | string | No | Book subtitle | Max 500 characters |
| `description` | string | No | Long-form book description (HTML from Audnex) | Max 10,000 characters |
| `summary` | string | No | Short summary/blurb | Max 2,000 characters |
| `runtimeLengthMin` | number | No | Total audiobook runtime in minutes | Positive integer |
| `image` | string | No | Cover image URL (typically Amazon CDN) | Valid URL format |
| `rating` | string | No | Aggregate Audible rating (e.g., "4.7 out of 5 stars") | String from Audnex API, not parsed to number |
| `releaseDate` | string | No | Book release date | ISO 8601 date string (YYYY-MM-DD) |
| `publisherName` | string | No | Publisher name | Max 255 characters |
| `isbn` | string | No | ISBN identifier (if available) | ISBN-10 or ISBN-13 format |
| `language` | string | No | Audio language code | Two-letter ISO 639-1 code (e.g., "en", "es") |
| `region` | string | No | Region code | Two-letter region code (e.g., "us", "uk") |
| `seriesAsin` | string | No | Foreign key to Series table | ASIN of the series this title belongs to |
| `seriesPosition` | string | No | Position in series (e.g., "Book 1", "1-3") | Freeform string from Audnex |
| `createdAt` | datetime | Yes | Timestamp when title was first added to catalog | Auto-generated on insert |
| `updatedAt` | datetime | Yes | Timestamp when title metadata was last updated | Auto-updated on any field change |

#### Relationships

- **Has many** LibraryEntry (one-to-many): A title can appear in multiple users' libraries
- **Has many** AuthorOnTitle (one-to-many): A title can have multiple authors via join table
- **Has many** NarratorOnTitle (one-to-many): A title can have multiple narrators via join table
- **Has many** Genre (many-to-many, implicit): A title can belong to multiple genres/tags
- **Belongs to** Series (many-to-one, optional): A title may be part of a series

#### Example Instances

**Complete Title with Series**:
```json
{
  "asin": "B09GHRGYRF",
  "title": "Project Hail Mary",
  "subtitle": null,
  "description": "<p>Ryland Grace is the sole survivor on a desperate, last-chance mission...</p>",
  "summary": "A lone astronaut must save the earth from disaster in this incredible new science-based thriller.",
  "runtimeLengthMin": 970,
  "image": "https://m.media-amazon.com/images/I/51D3O9hCVzL.jpg",
  "rating": "4.7 out of 5 stars",
  "releaseDate": "2021-05-04",
  "publisherName": "Audible Studios",
  "isbn": "9780593135204",
  "language": "en",
  "region": "us",
  "seriesAsin": null,
  "seriesPosition": null,
  "createdAt": "2026-02-11T10:00:00Z",
  "updatedAt": "2026-02-11T10:00:00Z"
}
```

**Title in Series**:
```json
{
  "asin": "B0FXBHJXPD",
  "title": "The Name of the Wind",
  "subtitle": "Kingkiller Chronicle, Book 1",
  "description": "<p>The riveting first-person narrative of a young man...</p>",
  "summary": "Told in Kvothe's own voice, this is the tale of the magically gifted young man.",
  "runtimeLengthMin": 1038,
  "image": "https://m.media-amazon.com/images/I/51vV0R5sDgL.jpg",
  "rating": "4.6 out of 5 stars",
  "releaseDate": "2008-04-01",
  "publisherName": "DAW",
  "isbn": "9780756404079",
  "language": "en",
  "region": "us",
  "seriesAsin": "B00K0OI42W",
  "seriesPosition": "Book 1",
  "createdAt": "2026-02-11T11:30:00Z",
  "updatedAt": "2026-02-11T11:30:00Z"
}
```

#### Validation Rules

**Cross-Field Validation**:
- If `seriesAsin` is provided, referenced Series record must exist
- ASIN uniqueness enforced at database level (primary key)
- If `runtimeLengthMin` is 0 or null, treat as unknown duration (not an error)

**Field-Specific Constraints**:
- `asin`: Must be non-empty, typically 10 alphanumeric characters (can vary for ISBNs)
- `title`: Required field from Audnex API, defaults to "Unknown Title - {ASIN}" if API returns empty
- `runtimeLengthMin`: Must be non-negative if provided
- `rating`: Stored as string to preserve Audnex format (e.g., "4.7 out of 5 stars" vs just "4.7")

---

### LibraryEntry

Join entity representing a user's relationship to a specific title. Contains all user-specific metadata (rating, listening status, progress) while referencing shared title metadata.

**Purpose**: Separate user-specific data from book metadata. Enables multiple users to own the same title without duplicating author names, cover images, etc. This is the core of the title catalog architecture.

**Source**: Created during import from extension JSON data, updated when user re-imports with new progress/ratings.

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `id` | string (cuid) | Yes | Unique library entry identifier | Auto-generated by database |
| `userId` | string | Yes | Foreign key to User table | Must reference existing User |
| `titleAsin` | string | Yes | Foreign key to Title table | Must reference existing Title |
| `userRating` | number | Yes | User's personal star rating (0-5) | Integer 0-5 inclusive, 0 means unrated |
| `status` | string | Yes | Listening progress status | Enum: "Finished", "Not Started", "In Progress" |
| `progress` | number | Yes | Listening progress percentage | Integer 0-100 inclusive |
| `timeLeft` | string | No | Remaining listening time (only for In Progress status) | Pattern: /^\d+[dhms]( \d+[dhms])*\s+left$/ (e.g., "15h 39m left") |
| `source` | string | Yes | Origin of the title (owned vs wishlist) | Enum: "LIBRARY", "WISHLIST" |
| `createdAt` | datetime | Yes | Timestamp when title was added to user's library | Auto-generated on insert |
| `updatedAt` | datetime | Yes | Timestamp when user-specific data was last updated | Auto-updated on any field change |

#### Relationships

- **Belongs to** User (many-to-one): Each library entry belongs to exactly one user
- **Belongs to** Title (many-to-one): Each library entry references exactly one title

#### Example Instances

**Finished Library Book**:
```json
{
  "id": "clxabc123def456ghi789jkl",
  "userId": "clx1a2b3c4d5e6f7g8h9i0j",
  "titleAsin": "B09GHRGYRF",
  "userRating": 5,
  "status": "Finished",
  "progress": 100,
  "timeLeft": null,
  "source": "LIBRARY",
  "createdAt": "2026-02-11T10:05:00Z",
  "updatedAt": "2026-02-11T15:20:00Z"
}
```

**In-Progress Library Book**:
```json
{
  "id": "clxmno456pqr789stu012vwx",
  "userId": "clx1a2b3c4d5e6f7g8h9i0j",
  "titleAsin": "B0FXBHJXPD",
  "userRating": 4,
  "status": "In Progress",
  "progress": 63,
  "timeLeft": "15h 39m left",
  "source": "LIBRARY",
  "createdAt": "2026-02-10T08:00:00Z",
  "updatedAt": "2026-02-11T12:45:00Z"
}
```

**Wishlist Item (Not Started)**:
```json
{
  "id": "clxyz789abc012def345ghi",
  "userId": "clx1a2b3c4d5e6f7g8h9i0j",
  "titleAsin": "B0FZWMD83N",
  "userRating": 0,
  "status": "Not Started",
  "progress": 0,
  "timeLeft": null,
  "source": "WISHLIST",
  "createdAt": "2026-02-09T14:30:00Z",
  "updatedAt": "2026-02-09T14:30:00Z"
}
```

#### Validation Rules

**Cross-Field Validation**:
- Unique constraint on `(userId, titleAsin)` - a user cannot have duplicate entries for the same title
- `progress` must be consistent with `status`: 0 for "Not Started", 100 for "Finished", 1-99 for "In Progress"
- `timeLeft` must only be present when `status === "In Progress"`
- `timeLeft` must be null when `status === "Finished"` or `status === "Not Started"`

**Field-Specific Constraints**:
- `userRating`: 0-5 inclusive, no decimals (integer only)
- `status`: Must be one of ["Finished", "Not Started", "In Progress"]
- `progress`: Must be 0-100 inclusive
- `timeLeft`: Must match pattern /^\d+[dhms]( \d+[dhms])*\s+left$/ if present
- `source`: Must be one of ["LIBRARY", "WISHLIST"]

#### State Transitions

**Listening Status State Machine**:
```
[Not Started] --user starts listening--> [In Progress]
[In Progress] --user continues listening--> [In Progress] (progress increases, timeLeft decreases)
[In Progress] --user finishes book--> [Finished]
[Finished] --permanent state--> [Finished]
```

**Notes**:
- Extension captures current state from Audible library, does not track transitions
- State is read-only from user's Audible library page
- No reverse transitions supported (Finished → In Progress would require Audible action)
- Progress can increase within "In Progress" state during re-imports

---

### Author

Represents a person who wrote a book. Authors have their own ASIN in Audible's system and can be linked to multiple titles.

**Purpose**: Store author information once and reference it from multiple titles. Enables querying titles by author and prevents author name duplication.

**Source**: Extracted from Audnex API response during title import (from `authors` array).

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `asin` | string | Yes | Audible author ASIN (unique identifier) | Alphanumeric, primary key |
| `name` | string | Yes | Author's full name | Non-empty, max 255 characters |
| `createdAt` | datetime | Yes | Timestamp when author was first added | Auto-generated on insert |
| `updatedAt` | datetime | Yes | Timestamp when author data was last updated | Auto-updated on any field change |

#### Relationships

- **Has many** AuthorOnTitle (one-to-many): An author can write multiple titles via join table
- **Has many** Title (many-to-many via AuthorOnTitle): An author can be linked to multiple titles

#### Example Instances

**Author with Single Name**:
```json
{
  "asin": "B000APZOQA",
  "name": "Andy Weir",
  "createdAt": "2026-02-11T10:00:00Z",
  "updatedAt": "2026-02-11T10:00:00Z"
}
```

**Author with Full Name**:
```json
{
  "asin": "B001IGFHW6",
  "name": "Patrick Rothfuss",
  "createdAt": "2026-02-11T11:30:00Z",
  "updatedAt": "2026-02-11T11:30:00Z"
}
```

#### Validation Rules

- `asin`: Unique constraint at database level (primary key)
- `name`: Index for efficient author name searches
- `name`: Cannot be empty string, defaults to "Unknown Author" if Audnex API returns null

---

### Narrator

Represents a person who narrated an audiobook. Unlike authors, narrators do not have ASINs in Audnex API data, so they use auto-generated IDs with unique name constraint.

**Purpose**: Store narrator information once and reference it from multiple titles. Enables querying titles by narrator and prevents narrator name duplication.

**Source**: Extracted from Audnex API response during title import (from `narrators` array).

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `id` | string (cuid) | Yes | Unique narrator identifier | Auto-generated by database |
| `name` | string | Yes | Narrator's full name | Non-empty, max 255 characters, unique across all narrators |
| `createdAt` | datetime | Yes | Timestamp when narrator was first added | Auto-generated on insert |
| `updatedAt` | datetime | Yes | Timestamp when narrator data was last updated | Auto-updated on any field change |

#### Relationships

- **Has many** NarratorOnTitle (one-to-many): A narrator can narrate multiple titles via join table
- **Has many** Title (many-to-many via NarratorOnTitle): A narrator can be linked to multiple titles

#### Example Instances

**Single Narrator**:
```json
{
  "id": "clxnar123abc456def789ghi",
  "name": "Ray Porter",
  "createdAt": "2026-02-11T10:00:00Z",
  "updatedAt": "2026-02-11T10:00:00Z"
}
```

**Narrator with Multiple Credits**:
```json
{
  "id": "clxnar789def012ghi345jkl",
  "name": "Nick Podehl",
  "createdAt": "2026-02-11T11:30:00Z",
  "updatedAt": "2026-02-11T11:30:00Z"
}
```

#### Validation Rules

- `name`: Unique constraint at database level (prevents duplicate narrators)
- `name`: Index for efficient narrator name searches
- `name`: Cannot be empty string, defaults to "Unknown Narrator" if Audnex API returns null or empty array

#### Implementation Notes

**Why no ASIN for Narrators?**: Audnex API does not provide ASINs for narrators (only `{ name: string }` objects). Narrators are identified by name uniqueness instead of ASIN. This requires special handling during import:

```typescript
// Find or create narrator by name (not ASIN)
const narrator = await prisma.narrator.upsert({
  where: { name: narratorData.name },
  create: { name: narratorData.name },
  update: {}
})
```

---

### Genre

Represents a category or tag for classifying titles. Genres have ASINs and can be of type "genre" (broad category) or "tag" (specific descriptor).

**Purpose**: Enable filtering and browsing titles by genre/tag. Supports many-to-many relationship (titles can have multiple genres, genres can contain multiple titles).

**Source**: Extracted from Audnex API response during title import (from `genres` array).

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `asin` | string | Yes | Audible genre/tag ASIN (unique identifier) | Alphanumeric, primary key |
| `name` | string | Yes | Genre or tag name | Non-empty, max 255 characters |
| `type` | string | Yes | Category type | Enum: "genre", "tag" |
| `createdAt` | datetime | Yes | Timestamp when genre was first added | Auto-generated on insert |

#### Relationships

- **Has many** Title (many-to-many, implicit): A genre can be applied to multiple titles

#### Example Instances

**Broad Genre**:
```json
{
  "asin": "B00NRQP3XM",
  "name": "Science Fiction",
  "type": "genre",
  "createdAt": "2026-02-11T10:00:00Z"
}
```

**Specific Tag**:
```json
{
  "asin": "B07P8R3YXD",
  "name": "Space Opera",
  "type": "tag",
  "createdAt": "2026-02-11T10:00:00Z"
}
```

**Narrow Genre**:
```json
{
  "asin": "B00NRQ0M0G",
  "name": "Adventure",
  "type": "genre",
  "createdAt": "2026-02-11T11:30:00Z"
}
```

#### Validation Rules

- `asin`: Unique constraint at database level (primary key)
- `name`: Index for efficient genre name searches
- `type`: Must be one of ["genre", "tag"]
- `type`: Index for filtering by type (e.g., show only broad genres, exclude tags)

---

### Series

Represents an audiobook series. Titles can reference a series via `seriesAsin` and specify their position in the series.

**Purpose**: Group related titles into series and maintain reading order. Enables browsing titles by series and displaying series information in UI.

**Source**: Extracted from Audnex API response during title import (from `seriesPrimary` object).

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `asin` | string | Yes | Audible series ASIN (unique identifier) | Alphanumeric, primary key |
| `name` | string | Yes | Series name | Non-empty, max 255 characters |
| `createdAt` | datetime | Yes | Timestamp when series was first added | Auto-generated on insert |
| `updatedAt` | datetime | Yes | Timestamp when series data was last updated | Auto-updated on any field change |

#### Relationships

- **Has many** Title (one-to-many): A series can contain multiple titles

#### Example Instances

**Popular Series**:
```json
{
  "asin": "B00K0OI42W",
  "name": "The Kingkiller Chronicle",
  "createdAt": "2026-02-11T11:30:00Z",
  "updatedAt": "2026-02-11T11:30:00Z"
}
```

**Long-Running Series**:
```json
{
  "asin": "B006K1LJDW",
  "name": "Wheel of Time",
  "createdAt": "2026-02-10T09:00:00Z",
  "updatedAt": "2026-02-10T09:00:00Z"
}
```

#### Validation Rules

- `asin`: Unique constraint at database level (primary key)
- `name`: Index for efficient series name searches
- `name`: Cannot be empty string, defaults to "Unknown Series" if Audnex API returns null

#### Implementation Notes

**Series Position**: The position of a title in its series is stored on the Title model (`seriesPosition` field), not in the Series model. This allows for flexible position formats like "Book 1", "1-3" (omnibus editions), "Book 0.5" (novellas), etc.

---

### SyncHistory

Audit log of import operations. Records metadata about each data import from the extension, including success/failure status and error details.

**Purpose**: Enable troubleshooting of import failures, track import frequency, and display import history to users. Supports debugging and monitoring of the import pipeline.

**Source**: Created automatically at the end of each import operation (POST /api/admin/import).

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `id` | string (cuid) | Yes | Unique sync history record identifier | Auto-generated by database |
| `userId` | string | Yes | Foreign key to User who initiated the import | Must reference existing User |
| `importDate` | datetime | Yes | Timestamp when import started | Auto-generated on insert |
| `titleCount` | number | Yes | Total number of titles in the import payload | Non-negative integer |
| `libraryCount` | number | Yes | Number of LIBRARY source titles imported | Non-negative integer |
| `wishlistCount` | number | Yes | Number of WISHLIST source titles imported | Non-negative integer |
| `successCount` | number | Yes | Number of titles successfully imported | Non-negative integer, <= titleCount |
| `failureCount` | number | Yes | Number of titles that failed to import | Non-negative integer, <= titleCount |
| `durationMs` | number | Yes | Total import processing time in milliseconds | Positive integer |
| `status` | string | Yes | Overall import status | Enum: "success", "partial", "failed" |
| `errors` | json | No | Array of error objects for failed titles | JSON array of `{ asin: string, error: string }` objects |

#### Relationships

- **Belongs to** User (many-to-one): Each sync history record belongs to exactly one user

#### Example Instances

**Successful Full Import**:
```json
{
  "id": "clxsync123abc456def789gh",
  "userId": "clx1a2b3c4d5e6f7g8h9i0j",
  "importDate": "2026-02-11T10:00:00Z",
  "titleCount": 143,
  "libraryCount": 119,
  "wishlistCount": 24,
  "successCount": 143,
  "failureCount": 0,
  "durationMs": 28500,
  "status": "success",
  "errors": null
}
```

**Partial Import with Failures**:
```json
{
  "id": "clxsync789def012ghi345jk",
  "userId": "clx1a2b3c4d5e6f7g8h9i0j",
  "importDate": "2026-02-11T15:30:00Z",
  "titleCount": 50,
  "libraryCount": 40,
  "wishlistCount": 10,
  "successCount": 47,
  "failureCount": 3,
  "durationMs": 12300,
  "status": "partial",
  "errors": [
    {
      "asin": "B0INVALID1",
      "error": "Audnex API returned 404 Not Found"
    },
    {
      "asin": "B0INVALID2",
      "error": "Network timeout after 3 retries"
    },
    {
      "asin": "B0INVALID3",
      "error": "Invalid ASIN format"
    }
  ]
}
```

**Complete Import Failure**:
```json
{
  "id": "clxsyncfail456xyz789abc",
  "userId": "clx1a2b3c4d5e6f7g8h9i0j",
  "importDate": "2026-02-11T16:00:00Z",
  "titleCount": 100,
  "libraryCount": 80,
  "wishlistCount": 20,
  "successCount": 0,
  "failureCount": 100,
  "durationMs": 5000,
  "status": "failed",
  "errors": [
    {
      "asin": "*",
      "error": "Database connection lost during import"
    }
  ]
}
```

#### Validation Rules

**Cross-Field Validation**:
- `successCount + failureCount` must equal `titleCount`
- `libraryCount + wishlistCount` must equal `titleCount`
- `status === "success"` requires `failureCount === 0`
- `status === "failed"` requires `successCount === 0`
- `status === "partial"` requires `successCount > 0 AND failureCount > 0`

**Field-Specific Constraints**:
- `titleCount`: Must be non-negative
- `successCount`: Must be non-negative and <= titleCount
- `failureCount`: Must be non-negative and <= titleCount
- `durationMs`: Must be positive integer
- `status`: Must be one of ["success", "partial", "failed"]
- `errors`: Must be JSON array of objects with `{ asin: string, error: string }` structure

---

## Join Tables

### AuthorOnTitle

Explicit join table linking Authors to Titles in a many-to-many relationship.

**Purpose**: Associate authors with titles while allowing future extension (e.g., author role: "Author" vs "Co-Author" vs "Editor").

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `authorAsin` | string | Yes | Foreign key to Author table | Must reference existing Author |
| `titleAsin` | string | Yes | Foreign key to Title table | Must reference existing Title |

#### Relationships

- **Belongs to** Author (many-to-one): Each join record links to exactly one author
- **Belongs to** Title (many-to-one): Each join record links to exactly one title

#### Constraints

- **Composite Primary Key**: `(authorAsin, titleAsin)` - prevents duplicate author-title links
- **Index**: `titleAsin` - optimizes queries for "all authors of this title"
- **Cascade Delete**: If Author or Title is deleted, join records are automatically deleted

---

### NarratorOnTitle

Explicit join table linking Narrators to Titles in a many-to-many relationship.

**Purpose**: Associate narrators with titles while allowing future extension (e.g., narrator role: "Primary Narrator" vs "Supporting Narrator").

#### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `narratorId` | string | Yes | Foreign key to Narrator table | Must reference existing Narrator |
| `titleAsin` | string | Yes | Foreign key to Title table | Must reference existing Title |

#### Relationships

- **Belongs to** Narrator (many-to-one): Each join record links to exactly one narrator
- **Belongs to** Title (many-to-one): Each join record links to exactly one title

#### Constraints

- **Composite Primary Key**: `(narratorId, titleAsin)` - prevents duplicate narrator-title links
- **Index**: `titleAsin` - optimizes queries for "all narrators of this title"
- **Cascade Delete**: If Narrator or Title is deleted, join records are automatically deleted

---

## Relationships

### Entity Relationship Diagram

```
User (1) ----< (N) LibraryEntry (N) >---- (1) Title
 |                                           |
 |                                           |----< (N) AuthorOnTitle (N) >---- (1) Author
 |                                           |
 ----< (N) SyncHistory                       |----< (N) NarratorOnTitle (N) >---- (1) Narrator
                                             |
                                             |----< (N) Genre (implicit many-to-many)
                                             |
                                             ----< (1) Series (optional)
```

### Relationship Descriptions

**User → LibraryEntry**:
- Relationship: One-to-many
- Description: A user can have zero or more library entries (titles in their library/wishlist)
- Foreign Key: `LibraryEntry.userId` references `User.id`
- Delete Behavior: Cascade (deleting a user deletes all their library entries)

**Title → LibraryEntry**:
- Relationship: One-to-many
- Description: A title can appear in zero or more user libraries
- Foreign Key: `LibraryEntry.titleAsin` references `Title.asin`
- Delete Behavior: Cascade (deleting a title deletes all library entries referencing it)

**User → SyncHistory**:
- Relationship: One-to-many
- Description: A user can have multiple import operations logged
- Foreign Key: `SyncHistory.userId` references `User.id`
- Delete Behavior: Cascade (deleting a user deletes their sync history)

**Title → AuthorOnTitle → Author**:
- Relationship: Many-to-many (explicit join table)
- Description: A title can have multiple authors, an author can write multiple titles
- Foreign Keys: `AuthorOnTitle.titleAsin` references `Title.asin`, `AuthorOnTitle.authorAsin` references `Author.asin`
- Delete Behavior: Cascade (deleting a title or author deletes the join records)

**Title → NarratorOnTitle → Narrator**:
- Relationship: Many-to-many (explicit join table)
- Description: A title can have multiple narrators, a narrator can narrate multiple titles
- Foreign Keys: `NarratorOnTitle.titleAsin` references `Title.asin`, `NarratorOnTitle.narratorId` references `Narrator.id`
- Delete Behavior: Cascade (deleting a title or narrator deletes the join records)

**Title → Genre**:
- Relationship: Many-to-many (implicit, Prisma managed)
- Description: A title can belong to multiple genres/tags, a genre can contain multiple titles
- Implementation: Prisma creates implicit join table `_GenreToTitle` with `(A: genreAsin, B: titleAsin)`
- Delete Behavior: Cascade (deleting a title or genre deletes the join records)

**Title → Series**:
- Relationship: Many-to-one (optional)
- Description: A title may belong to a series, a series can contain multiple titles
- Foreign Key: `Title.seriesAsin` references `Series.asin`
- Delete Behavior: Set null (deleting a series does not delete titles, just clears `seriesAsin`)

---

## Validation Rules

### Cross-Entity Validation

**Import Process Validation**:
1. Before creating LibraryEntry, verify Title exists (or fetch from Audnex API)
2. Before linking Author, verify Author exists in catalog (or create from Audnex data)
3. Before linking Narrator, verify Narrator exists by name (or create from Audnex data)
4. Before linking Genre, verify Genre exists in catalog (or create from Audnex data)
5. Before linking Series, verify Series exists in catalog (or create from Audnex data)

**Referential Integrity**:
- All foreign keys must reference existing records (enforced by database)
- Unique constraint on `(userId, titleAsin)` in LibraryEntry prevents duplicate library entries
- Unique constraint on `name` in Narrator prevents duplicate narrator records
- Composite primary keys in join tables prevent duplicate associations

**Data Consistency**:
- LibraryEntry.status must match LibraryEntry.progress (0 for Not Started, 100 for Finished, 1-99 for In Progress)
- LibraryEntry.timeLeft must only be present when status is "In Progress"
- SyncHistory.successCount + failureCount must equal titleCount
- SyncHistory.status must match success/failure counts (success requires failureCount=0, failed requires successCount=0)

---

## Comparison with Previous Model

### New Entities (Not in 003-simplify-extension)

This feature introduces the server-side data model that complements the extension's simplified data model:

| Entity | Purpose | Source |
|--------|---------|--------|
| Title | Canonical book metadata shared across users | Audnex API |
| LibraryEntry | User-specific data (ratings, progress, status) | Extension JSON import |
| Author | Author information with ASIN | Audnex API |
| Narrator | Narrator information (no ASIN) | Audnex API |
| Genre | Genre/tag classification | Audnex API |
| Series | Series grouping | Audnex API |
| SyncHistory | Import operation audit log | Import endpoint |

### Extension Data → Platform Mapping

The extension produces `UserLibraryTitle` objects (from 003-simplify-extension). The import process transforms these into server-side entities:

**Extension Field** → **Platform Entity/Field**:
- `asin` → `Title.asin` (lookup key)
- `title` → `Title.title` (fallback if Audnex fails)
- `userRating` → `LibraryEntry.userRating`
- `status` → `LibraryEntry.status`
- `progress` → `LibraryEntry.progress`
- `timeLeft` → `LibraryEntry.timeLeft`
- `source` → `LibraryEntry.source`

**Audnex API Data** → **Platform Entities**:
- `authors[]` → `Author` records + `AuthorOnTitle` join records
- `narrators[]` → `Narrator` records + `NarratorOnTitle` join records
- `genres[]` → `Genre` records + implicit join table
- `seriesPrimary` → `Series` record + `Title.seriesAsin` reference
- All other Audnex fields → `Title` fields (description, runtimeLengthMin, rating, etc.)

### Architecture Change: Title Catalog

**Previous Architecture (implied by extension-only design)**:
- Extension scrapes all book metadata from Audible pages
- Platform stores complete book data per user (high duplication)

**New Architecture (004-admin-dashboard)**:
- Extension scrapes only user-specific data (ratings, progress, status)
- Platform fetches book metadata once from Audnex API
- Title catalog stores shared metadata (authors, narrators, cover, description)
- LibraryEntry stores user-specific data (ratings, progress, status)
- Multiple users can reference the same Title without metadata duplication

**Benefits**:
- 90% reduction in storage per user (no duplicated author names, cover URLs, descriptions)
- Single source of truth for book metadata (admin can update title, all users see changes)
- Faster imports (extension scrapes less data, platform caches Audnex responses)
- Enables features like "all users who read this book" or "most popular titles across users"

---

## Implementation Notes

### Prisma Schema Pattern

```prisma
model User {
  id             String         @id @default(cuid())
  email          String         @unique
  name           String?
  image          String?
  isAdmin        Boolean        @default(false)
  libraryEntries LibraryEntry[]
  syncHistory    SyncHistory[]
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
}

model Title {
  asin              String             @id
  title             String
  subtitle          String?
  description       String?            @db.Text
  summary           String?            @db.Text
  runtimeLengthMin  Int?
  image             String?
  rating            String?
  releaseDate       String?
  publisherName     String?
  isbn              String?
  language          String?
  region            String?
  seriesAsin        String?
  seriesPosition    String?
  authors           AuthorOnTitle[]
  narrators         NarratorOnTitle[]
  genres            Genre[]
  series            Series?            @relation(fields: [seriesAsin], references: [asin], onDelete: SetNull)
  libraryEntries    LibraryEntry[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([title])
  @@index([seriesAsin])
}

model LibraryEntry {
  id         String   @id @default(cuid())
  userId     String
  titleAsin  String
  userRating Int      @default(0)
  status     String
  progress   Int      @default(0)
  timeLeft   String?
  source     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  title      Title    @relation(fields: [titleAsin], references: [asin], onDelete: Cascade)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([userId, titleAsin])
  @@index([userId])
  @@index([titleAsin])
  @@index([source])
  @@index([status])
}

model Author {
  asin      String          @id
  name      String
  titles    AuthorOnTitle[]
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([name])
}

model AuthorOnTitle {
  author     Author   @relation(fields: [authorAsin], references: [asin], onDelete: Cascade)
  authorAsin String
  title      Title    @relation(fields: [titleAsin], references: [asin], onDelete: Cascade)
  titleAsin  String

  @@id([authorAsin, titleAsin])
  @@index([titleAsin])
}

model Narrator {
  id        String            @id @default(cuid())
  name      String            @unique
  titles    NarratorOnTitle[]
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  @@index([name])
}

model NarratorOnTitle {
  narrator   Narrator @relation(fields: [narratorId], references: [id], onDelete: Cascade)
  narratorId String
  title      Title    @relation(fields: [titleAsin], references: [asin], onDelete: Cascade)
  titleAsin  String

  @@id([narratorId, titleAsin])
  @@index([titleAsin])
}

model Genre {
  asin      String   @id
  name      String
  type      String
  titles    Title[]
  createdAt DateTime @default(now())

  @@index([name])
  @@index([type])
}

model Series {
  asin      String   @id
  name      String
  titles    Title[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model SyncHistory {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  importDate    DateTime @default(now())
  titleCount    Int
  libraryCount  Int
  wishlistCount Int
  successCount  Int
  failureCount  Int
  durationMs    Int
  status        String
  errors        Json?

  @@index([userId])
  @@index([importDate])
}
```

### Query Patterns

**Fetch User's Library with Full Title Details**:
```typescript
const library = await prisma.libraryEntry.findMany({
  where: { userId: 'clx1a2b3c4d5e6f7g8h9i0j' },
  include: {
    title: {
      include: {
        authors: { include: { author: true } },
        narrators: { include: { narrator: true } },
        genres: true,
        series: true
      }
    }
  }
})
```

**Find or Create Author (Upsert Pattern)**:
```typescript
const author = await prisma.author.upsert({
  where: { asin: 'B000APZOQA' },
  create: { asin: 'B000APZOQA', name: 'Andy Weir' },
  update: {} // No-op if exists
})
```

**Find or Create Narrator by Name**:
```typescript
const narrator = await prisma.narrator.upsert({
  where: { name: 'Ray Porter' },
  create: { name: 'Ray Porter' },
  update: {} // No-op if exists
})
```

**Create Title with All Relations (Transaction)**:
```typescript
await prisma.$transaction(async (tx) => {
  // Create or update Title
  const title = await tx.title.upsert({
    where: { asin: 'B09GHRGYRF' },
    create: { /* title fields */ },
    update: { /* title fields */ }
  })

  // Link authors
  for (const authorData of audnexData.authors) {
    const author = await tx.author.upsert({
      where: { asin: authorData.asin },
      create: authorData,
      update: {}
    })
    await tx.authorOnTitle.upsert({
      where: {
        authorAsin_titleAsin: {
          authorAsin: author.asin,
          titleAsin: title.asin
        }
      },
      create: {
        authorAsin: author.asin,
        titleAsin: title.asin
      },
      update: {}
    })
  }

  // Similar for narrators, genres, series...
})
```

### Performance Considerations

**Indexes**:
- `User.email` (unique) - fast user lookup by email
- `Title.title` - fast title search
- `Author.name`, `Narrator.name`, `Genre.name`, `Series.name` - fast name-based searches
- `LibraryEntry(userId, titleAsin)` (unique) - fast duplicate detection during import
- `LibraryEntry.source`, `LibraryEntry.status` - fast filtering by source/status

**Query Optimization**:
- Use `include` selectively (only load relations needed for current view)
- Paginate title lists (50 titles per page in admin UI)
- Batch Audnex API calls (10 concurrent requests via Promise.allSettled)
- Cache Audnex responses in Title table (never re-fetch same ASIN)

**Bulk Operations**:
- Drop user library: `DELETE FROM LibraryEntry WHERE userId = ?` (single query)
- Drop all titles: `DELETE FROM Title` (cascades to AuthorOnTitle, NarratorOnTitle, LibraryEntry)
- Import 100 titles: Use transactions to ensure atomicity, batch API calls for speed

---

## JSON Schema Reference

For formal validation of import payloads, see:
- Extension output schema: [/specs/003-simplify-extension/contracts/extension-output.schema.json](../003-simplify-extension/contracts/extension-output.schema.json)
- Import endpoint request/response: [/specs/004-admin-dashboard/contracts/import.yaml](./contracts/import.yaml) (to be created)
